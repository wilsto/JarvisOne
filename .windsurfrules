# JarvisOne

## Project Context

JarvisOne is a modular and scalable conversational AI assistant.

- Uses multiple LLM models (Gemini 2.0, ChatGPT-4, Ollama) for increased flexibility 
- Integrates RAG (Retrieval-Augmented Generation) capabilities for enhanced contextualization (À conserver pour plus tard)
- Designed with a modular architecture allowing easy addition of new features
- Includes document management capabilities and user-friendly interface
- **Core interface is a chat, allowing natural language interaction**
- **Uses `everything` for file search functionality, leveraging its interface for output when appropriate.**
- **Implements a layered architecture inspired by the provided diagram, ensuring modularity and security.**

## Tech Stack

- Use Uv for Python development
- Python 3.12
- Streamlit 1.31+
- Gemini 2.0 / ChatGPT-4 / Ollama 
- Pytest + Streamlit Testing
- LangChain (À conserver pour plus tard)
- FAISS (À conserver pour plus tard)
- SentenceTransformers (À conserver pour plus tard)
- PyYAML (À conserver pour plus tard)
- GTTS / SpeechRecognition (À conserver pour plus tard)

## Tools Used

- Everything (<https://www.voidtools.com/>): File search tool.
  - Path : C:\Program Files\Everything\es.exe
    -Documentation Command line: docs\everything.md

## Interface Utilisateur avec Streamlit

- Use Streamlit to create an interactive and responsive chat interface
- Utilize Streamlit's built-in components for quick setup
- Customize the appearance with Streamlit's themes
- Implement a responsive layout using `st.columns` and `st.tabs` 
- Use `st.session_state` for state management
- Document the usage of specific Streamlit components in the code
- Integrate UI configuration parameters from `config.yaml` (À conserver pour plus tard)
- **Main interface is a chat using Streamlit's input text element**
- **Leverage external tool's interface for output whenever possible to avoid re-implementation. For example, `anything`'s output is displayed using its interface.**
- **For tools that don't have an interface or where an integration is necessary, output will be redirected to the chat interface**

## Unit Testing Guidelines

### Test Structure and Organization
- All test files must follow the pattern `test_*.py`
- Tests should be organized mirroring the source code structure
- Use centralized mock utilities from (tests/utils.py)
- Group tests by feature/functionality using test classes
- Use descriptive test names that explain the test scenario
- Before writing tests, review nearby test files to maintain consistency

### Mock Utilities (tests/utils.py)
- Use the provided (MockSessionState) for Streamlit tests
- All new mock utilities must be added to (tests/utils.py)
- Document each mock utility with clear docstrings
- Keep mock utilities generic and reusable

### Test Coverage Requirements
- Minimum 80% code coverage for new features
- 100% coverage for critical paths
- Test both success and error scenarios
- Include edge cases and boundary conditions

### Test Modification Flag
- Add comment `#TODO: TEST_UPDATE_NEEDED` when code changes require test updates
- Document which test cases need to be added/modified
- Never modify tests without explicit USER approval

### Best Practices
- Use pytest fixtures for test setup
- Keep tests independent and idempotent
- Mock external dependencies and API calls
- Use parameterized tests for multiple scenarios
- Follow Arrange-Act-Assert pattern

## Objectifs, Dépendances et Contraintes (ODC)

- Les ODC techniques sont documentées dans le fichier `odc_technique.md`.
- Les ODC d'architecture sont documentées dans le fichier `odc_architecture.md`.
