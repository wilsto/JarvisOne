# JarvisOne

## Project Context

JarvisOne is a modular and scalable conversational AI assistant.

- Uses multiple LLM models (Gemini 2.0, ChatGPT-4, Ollama) for increased flexibility 
- Integrates RAG (Retrieval-Augmented Generation) capabilities for enhanced contextualization (À conserver pour plus tard)
- Designed with a modular architecture allowing easy addition of new features
- Includes document management capabilities and user-friendly interface
- **Core interface is a chat, allowing natural language interaction**
- **Uses `everything` for file search functionality, leveraging its interface for output when appropriate.**
- **Implements a layered architecture inspired by the provided diagram, ensuring modularity and security.**

## Repository File Structure

JarvisOne/
├── main.py                   # Main entry point
├── config/                   # Configuration files
│   └── config.yaml          # Main configuration file
├── data/                    # Data and embeddings
├── docs/                    # Documentation
│   └── everything.md        # Everything CLI documentation
├── log/                     # Log files
├── src/                     # Main source code
│   ├── core/               # Core logic
│   │   ├── providers/     # LLM-specific implementations (À conserver pour plus tard)
│   │   └── config_manager.py # Configuration manager (À conserver pour plus tard)
│   ├── features/          # Main features
│   │   ├── file_search.py    # Module for file searching with `anything`
│   │   ├── agents/       # LLM agents
│   │   │   └── file_search_agent.py # Agent for file searching
│   │   │   └── query_analyzer_agent.py  # Agent for understanding user queries
│   │   ├── rag_module.py     # RAG module (À conserver pour plus tard)
│   │   └── document_manager.py # Document manager (À conserver pour plus tard)
│   ├── types/             # Types and schemas (À conserver pour plus tard)
│   ├── utils/            # Utilities
│   │   └── logging_config.py # Logging configuration (À conserver pour plus tard)
│   └── ui/               # User interface
│       ├── chat_ui.py      # Chat interface
│       ├── streamlit_components.py # Streamlit components (À conserver pour plus tard)
│       └── document_ui.py    # Document management interface (À conserver pour plus tard)
├── tests/                 # Unit and integration tests
├── .env                   # Environment variables
├── .gitignore            # Git ignore file
├── LICENSE               # License file
├── README.md             # Project documentation
├── requirements.txt      # Python dependencies
└── odc_*.md             # ODC documentation files

## Tech Stack

- Use Uv for Python development
- Python 3.12
- Streamlit 1.31+
- Gemini 2.0 / ChatGPT-4 / Ollama 
- Pytest + Streamlit Testing
- LangChain (À conserver pour plus tard)
- FAISS (À conserver pour plus tard)
- SentenceTransformers (À conserver pour plus tard)
- PyYAML (À conserver pour plus tard)
- GTTS / SpeechRecognition (À conserver pour plus tard)

## Tools Used

- Everything (<https://www.voidtools.com/>): File search tool.
  - Path : C:\Program Files\Everything\es.exe
    -Documentation Command line: docs\everything.md

## Interface Utilisateur avec Streamlit

- Use Streamlit to create an interactive and responsive chat interface
- Utilize Streamlit's built-in components for quick setup
- Customize the appearance with Streamlit's themes
- Implement a responsive layout using `st.columns` and `st.tabs` 
- Use `st.session_state` for state management
- Document the usage of specific Streamlit components in the code
- Integrate UI configuration parameters from `config.yaml` (À conserver pour plus tard)
- **Main interface is a chat using Streamlit's input text element**
- **Leverage external tool's interface for output whenever possible to avoid re-implementation. For example, `anything`'s output is displayed using its interface.**
- **For tools that don't have an interface or where an integration is necessary, output will be redirected to the chat interface**

## Unit Testing Guidelines

### Test Structure and Organization
- All test files must follow the pattern `test_*.py`
- Tests should be organized mirroring the source code structure
- Use centralized mock utilities from (tests/utils.py)
- Group tests by feature/functionality using test classes
- Use descriptive test names that explain the test scenario

### Mock Utilities (tests/utils.py)
- Use the provided (MockSessionState)for Streamlit tests
- All new mock utilities must be added to (tests/utils.py)
- Document each mock utility with clear docstrings
- Keep mock utilities generic and reusable

### Test Coverage Requirements
- Minimum 80% code coverage for new features
- 100% coverage for critical paths
- Test both success and error scenarios
- Include edge cases and boundary conditions

### Test Modification Flag
- Add comment `#TODO: TEST_UPDATE_NEEDED` when code changes require test updates
- Document which test cases need to be added/modified
- Never modify tests without explicit USER approval

### Best Practices
- Use pytest fixtures for test setup
- Keep tests independent and idempotent
- Mock external dependencies and API calls
- Use parameterized tests for multiple scenarios
- Follow Arrange-Act-Assert pattern

## Objectifs, Dépendances et Contraintes (ODC)

- Les ODC techniques sont documentées dans le fichier `odc_technique.md`.
- Les ODC d'architecture sont documentées dans le fichier `odc_architecture.md`.
